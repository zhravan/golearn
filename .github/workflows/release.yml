name: Build, tag, and release

on:
  pull_request:
    types: [closed]
    branches: ["main"]

permissions:
  contents: write
  pull-requests: read

jobs:
  build-and-release:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod
          cache: true

      - name: Verify build
        run: |
          go vet ./...
          go build -v ./cmd/golearn

      - name: Determine next version from labels
        id: bump
        run: |
          labels='${{ toJson(github.event.pull_request.labels) }}'
          lower=$(echo "$labels" | tr '[:upper:]' '[:lower:]')
          bump="patch"
          if echo "$lower" | grep -q '"name"\s*:\s*"major"'; then
            bump="major"
          elif echo "$lower" | grep -q '"name"\s*:\s*"minor"'; then
            bump="minor"
          fi
          echo "bump=$bump" >> $GITHUB_OUTPUT

      - name: Get latest tag
        id: get_tag
        run: |
          latest=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "latest=$latest" >> $GITHUB_OUTPUT

      - name: Compute next tag
        id: next
        run: |
          latest="${{ steps.get_tag.outputs.latest }}"
          echo "Latest tag: $latest"
          ver=${latest#v}
          IFS='.' read -r major minor patch <<EOF
          $ver
          EOF
          case "${{ steps.bump.outputs.bump }}" in
            major)
              major=$((major+1)); minor=0; patch=0;
              ;;
            minor)
              minor=$((minor+1)); patch=0;
              ;;
            patch)
              patch=$((patch+1));
              ;;
          esac
          next="v${major}.${minor}.${patch}"
          echo "next=$next" >> $GITHUB_OUTPUT

      - name: Create tag and release
        id: create_release
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          next="${{ steps.next.outputs.next }}"
          echo "Creating release: $next"
          
          # Check if tag already exists
          if git rev-parse "$next" >/dev/null 2>&1; then
            echo "Tag $next already exists, skipping tag creation"
          else
            # Create and push tag
            git tag "$next"
            git push origin "$next"
          fi
          
          # Create release with proper error handling
          if gh release view "$next" >/dev/null 2>&1; then
            echo "Release $next already exists, will update it"
          elif gh release create "$next" --generate-notes; then
            echo "Release $next created successfully"
          else
            echo "Failed to create release $next"
            exit 1
          fi

      - name: Attach binaries (Linux/macOS)
        if: steps.create_release.outcome == 'success'
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
        run: |
          next="${{ steps.next.outputs.next }}"
          echo "Uploading binaries for release: $next"
          
          # Build static binaries for common platforms
          mkdir -p dist
          echo "Building binaries..."
          GOOS=linux GOARCH=amd64 go build -o dist/golearn-linux-amd64 ./cmd/golearn
          GOOS=darwin GOARCH=arm64 go build -o dist/golearn-darwin-arm64 ./cmd/golearn
          GOOS=darwin GOARCH=amd64 go build -o dist/golearn-darwin-amd64 ./cmd/golearn
          GOOS=windows GOARCH=amd64 go build -o dist/golearn-windows-amd64.exe ./cmd/golearn
          
          echo "Binaries built successfully:"
          ls -lh dist/
          
          # Upload binaries to the release with retry logic
          max_attempts=3
          attempt=1
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt of $max_attempts to upload binaries..."
            if gh release upload "$next" dist/* --clobber; then
              echo "Binaries uploaded successfully"
              exit 0
            else
              echo "Upload attempt $attempt failed"
              if [ $attempt -eq $max_attempts ]; then
                echo "Failed to upload binaries after $max_attempts attempts"
                exit 1
              fi
              attempt=$((attempt+1))
              sleep 2
            fi
          done

